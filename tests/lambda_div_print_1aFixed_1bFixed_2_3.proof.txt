{ true } Type { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) } 

  preconditions  Value { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) } 

  preconditions  Context { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) } 

  preconditions  ErrContext { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) } 

  preconditions  ErrContext { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-INT-FLOAT { Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-INT { Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-FLOAT { Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-UNIT { Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-ARROW { Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-INT { ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-FLOAT { ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-DIV { ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-ABS { ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-APP-BAD { ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-UNITT { ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-PRINT { ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-ERROR { ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-SEQ { ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-TRY { ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  BETA { NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  SEQ { NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  DIV { NoDupli(DIV) /\ CtxCompliant(DIV) /\ NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  PRINT { NoDupli(PRINT) /\ Effectful /\ CtxCompliant(PRINT) /\ NoDupli(DIV) /\ CtxCompliant(DIV) /\ NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  TRY { NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(PRINT) /\ Effectful /\ CtxCompliant(PRINT) /\ NoDupli(DIV) /\ CtxCompliant(DIV) /\ NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  ERR { NoDupli(ERR) /\ CtxCompliant(ERR) /\ NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(PRINT) /\ Effectful /\ CtxCompliant(PRINT) /\ NoDupli(DIV) /\ CtxCompliant(DIV) /\ NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) }
---- (LAN)
{ true } (G,I) { NoDupli(ERR) /\ CtxCompliant(ERR) /\ NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(PRINT) /\ Effectful /\ CtxCompliant(PRINT) /\ NoDupli(DIV) /\ CtxCompliant(DIV) /\ NoDupli(SEQ) /\ CtxCompliant(SEQ) /\ NoDupli(BETA) /\ CtxCompliant(BETA) /\ ContraResp(T-TRY, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-PRINT, arrow) /\ ContraResp(T-UNITT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Contra(arrow, [1]) /\ Contra(unitt, []) /\ Contra(float, []) /\ Contra(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, unitt, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, app, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, app, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, print, []) /\ Inductive(C, error, []) }
---- (CONSEQUENCE)
{ true } (G,I) { CtxCompliant(BETA) }

{ true } Type { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) } 

  preconditions  Value { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) } 

  preconditions  Error { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) } 

  preconditions  Context { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) } 

  preconditions  ErrContext { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) } 

  preconditions  ErrContext { true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-INT-FLOAT { Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-INT { Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-FLOAT { Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REFL-UNIT { Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-ARROW { Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  S-REF { Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-INT { ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-FLOAT { ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-DIV { ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-PLUS { ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-ABS { ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-APP-BAD { ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-UNIT { ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-LABEL { ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-REF { ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-DEREF { ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-ASSIGN { ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-SEQ { ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-ERROR { ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  T-TRY { ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  BETA { NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-REF { NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-DEREF { NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-ASSIGN { NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-SEQ { NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-DIV { NoDupli(R-DIV) /\ CtxCompliant(R-DIV) /\ NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  R-PLUS { NoDupli(R-PLUS) /\ CtxCompliant(R-PLUS) /\ NoDupli(R-DIV) /\ CtxCompliant(R-DIV) /\ NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  TRY { NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(R-PLUS) /\ CtxCompliant(R-PLUS) /\ NoDupli(R-DIV) /\ CtxCompliant(R-DIV) /\ NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) } 

 
---- (ITERATE)
 preconditions  ERR { NoDupli(ERR) /\ CtxCompliant(ERR) /\ NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(R-PLUS) /\ CtxCompliant(R-PLUS) /\ NoDupli(R-DIV) /\ CtxCompliant(R-DIV) /\ NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) }
---- (LAN)
{ true } (G,I) { NoDupli(ERR) /\ CtxCompliant(ERR) /\ NoDupli(TRY) /\ CtxCompliant(TRY) /\ NoDupli(R-PLUS) /\ CtxCompliant(R-PLUS) /\ NoDupli(R-DIV) /\ CtxCompliant(R-DIV) /\ NoDupli(R-SEQ) /\ CtxCompliant(R-SEQ) /\ NoDupli(R-ASSIGN) /\ Effectful /\ CtxCompliant(R-ASSIGN) /\ NoDupli(R-DEREF) /\ CtxCompliant(R-DEREF) /\ NoDupli(R-REF) /\ CtxCompliant(R-REF) /\ NoDupli(BETA) /\ ContraResp(T-TRY, arrow) /\ ErrorAnyType(error) /\ ContraResp(T-ERROR, arrow) /\ ContraResp(T-SEQ, arrow) /\ ContraResp(T-ASSIGN, arrow) /\ ContraResp(T-DEREF, arrow) /\ ContraResp(T-REF, arrow) /\ ContraResp(T-LABEL, arrow) /\ ContraResp(T-UNIT, arrow) /\ ContraResp(T-ABS, arrow) /\ ContraResp(T-PLUS, arrow) /\ ContraResp(T-DIV, arrow) /\ ContraResp(T-FLOAT, arrow) /\ ContraResp(T-INT, arrow) /\ Invariant(refType, [1]) /\ Contra(refType, []) /\ Invariant(arrow, []) /\ Contra(arrow, [1]) /\ Invariant(unitType, []) /\ Contra(unitType, []) /\ Invariant(float, []) /\ Contra(float, []) /\ Invariant(int, []) /\ Contra(int, []) /\ Invariant(int, []) /\ Contra(int, []) /\ true /\ Inductive(T, int, []) /\ Inductive(T, float, []) /\ Inductive(T, arrow, [1; 2]) /\ Inductive(T, refType, [1]) /\ Inductive(T, unitType, []) /\ Inductive(V, num, []) /\ Inductive(V, float, []) /\ Inductive(V, abs, []) /\ Inductive(V, unit, []) /\ Inductive(V, label, []) /\ Error(error) /\ Inductive(C, div, [1]) /\ Inductive(C, div, [2]) /\ Inductive(C, plus, [1]) /\ Inductive(C, plus, [2]) /\ Inductive(C, app, [1]) /\ Inductive(C, ref, [1]) /\ Inductive(C, deref, [1]) /\ Inductive(C, assign, [1]) /\ Inductive(C, assign, [2]) /\ Inductive(C, seq, [1]) /\ Inductive(C, try, [1]) /\ Inductive(F, div, [1]) /\ Inductive(F, div, [2]) /\ Inductive(F, plus, [1]) /\ Inductive(F, plus, [2]) /\ Inductive(F, app, [1]) /\ Inductive(F, ref, [1]) /\ Inductive(F, deref, [1]) /\ Inductive(F, assign, [1]) /\ Inductive(F, assign, [2]) /\ Inductive(F, seq, [1]) /\ Inductive(F, try, [1]) /\ Inductive(C, num, []) /\ Inductive(C, float, []) /\ Inductive(C, abs, []) /\ Inductive(C, unit, []) /\ Inductive(C, label, []) /\ Inductive(C, error, []) }
---- (CONSEQUENCE)
{ true } (G,I) { NoDupli(BETA) }
